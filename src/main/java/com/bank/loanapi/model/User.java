package com.bank.loanapi.model;

import com.fasterxml.jackson.annotation.JsonIgnore;
import jakarta.persistence.*;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.stream.Collectors;

@Data // Lombok: Generates @Getter, @Setter, @ToString, @EqualsAndHashCode
@NoArgsConstructor // Lombok: Generates a no-argument constructor
@Entity // Marks this class as a JPA entity
@Table(name = "app_users") // Using "app_users" as "USER" can be a reserved keyword in SQL.
public class User implements UserDetails {

    @Id // Marks this field as the primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Configures the ID to be auto-generated by the database
    private Long id;

    @Column(nullable = false, unique = true) // Username must be non-null and unique
    private String username;

    @Column(nullable = false) // Password must be non-null
    private String password; // Stores the encoded password

    // Roles will be stored as a comma-separated string, e.g., "ROLE_ADMIN,ROLE_CUSTOMER"
    private String roles;

    // One-to-One inverse relationship with Customer.
    // "mappedBy = user" indicates that the 'user' field in the Customer entity is the owner of this relationship.
    @OneToOne(mappedBy = "user")
    @JsonIgnore // Prevents serialization issues if User is serialized and Customer has a back-reference to User.
    @ToString.Exclude // Prevents infinite loops in toString() due to bidirectional relationship with Customer.
    private Customer customer;

    // Constructor for creating a User with username, password, and roles.
    public User(String username, String password, String roles) {
        this.username = username;
        this.password = password;
        this.roles = roles;
    }

    /**
     * Returns the authorities granted to the user.
     * Parses the comma-separated 'roles' string into a collection of SimpleGrantedAuthority objects.
     */
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        if (this.roles == null || this.roles.isBlank()) {
            return new HashSet<>(); // Return an empty set if no roles are defined.
        }
        // Converts a string like "ROLE_ADMIN,ROLE_CUSTOMER" into a list of GrantedAuthority objects.
        return Arrays.stream(this.roles.split(","))
                .map(String::trim) // Trim whitespace from role strings
                .filter(role -> !role.isEmpty()) // Filter out empty role strings
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toSet());
    }

    /**
     * Returns the password used to authenticate the user.
     */
    @Override
    public String getPassword() {
        return this.password;
    }

    /**
     * Returns the username used to authenticate the user.
     */
    @Override
    public String getUsername() {
        return this.username;
    }

    // The following UserDetails methods relate to account status.
    // For this application, they are simplified to always return true.
    // In a production application, these could be backed by database fields.

    /**
     * Indicates whether the user's account has expired. An expired account cannot be authenticated.
     * @return {@code true} if the user's account is valid (ie non-expired), {@code false} if no longer valid
     */
    @Override
    public boolean isAccountNonExpired() {
        return true; // Account never expires
    }

    /**
     * Indicates whether the user is locked or unlocked. A locked user cannot be authenticated.
     * @return {@code true} if the user is not locked, {@code false} otherwise
     */
    @Override
    public boolean isAccountNonLocked() {
        return true; // Account is never locked
    }

    /**
     * Indicates whether the user's credentials (password) has expired. Expired credentials prevent authentication.
     * @return {@code true} if the user's credentials are valid (ie non-expired), {@code false} if no longer valid
     */
    @Override
    public boolean isCredentialsNonExpired() {
        return true; // Credentials never expire
    }

    /**
     * Indicates whether the user is enabled or disabled. A disabled user cannot be authenticated.
     * @return {@code true} if the user is enabled, {@code false} otherwise
     */
    @Override
    public boolean isEnabled() {
        return true; // Account is always enabled
    }
}